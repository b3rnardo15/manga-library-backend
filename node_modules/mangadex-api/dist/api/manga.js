"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MangaResolver = void 0;
const Agent_1 = require("../Agent");
const base_1 = require("./base");
const user_1 = require("./user");
const cover_art_1 = require("./cover-art");
const relationship_type_1 = require("../lib/relationship-type");
const format_query_params_1 = require("../lib/format-query-params");
class MangaResolver extends base_1.ApiBase {
    /**
     * Get a manga
     * @param mangaId The manga ID
     * @param options Request options
     */
    async getManga(mangaId, options = {}) {
        const { data: manga } = await this.agent.call(`manga/${mangaId}`);
        if (manga.result === 'error') {
            return manga;
        }
        const artists = relationship_type_1.getRelationshipType('artist', manga.relationships);
        const author = relationship_type_1.getRelationshipType('author', manga.relationships)[0];
        const coverArts = relationship_type_1.getRelationshipType('cover_art', manga.relationships);
        if (!options.withRelationShips) {
            return manga;
        }
        manga.data.attributes.artist = await Promise.all(artists.map(({ id }) => user_1.UserResolver.getUser(id)));
        manga.data.attributes.author = await user_1.UserResolver.getUser(author.id);
        manga.data.attributes.cover_art = await Promise.all(coverArts.map(({ id }) => cover_art_1.CoverArtResolver.getCoverArt(id)));
        return manga;
    }
    /**
     * Get a manga
     * @param mangaId The manga ID
     * @param options Request options
     */
    static async getManga(mangaId, options = {}) {
        const { data: manga } = await Agent_1.Agent.call(`manga/${mangaId}`);
        if (manga.result === 'error') {
            return manga;
        }
        const artists = relationship_type_1.getRelationshipType('artist', manga.relationships);
        const author = relationship_type_1.getRelationshipType('author', manga.relationships)[0];
        const coverArts = relationship_type_1.getRelationshipType('cover_art', manga.relationships);
        if (!options.withRelationShips) {
            return manga;
        }
        manga.data.attributes.artist = await Promise.all(artists.map(({ id }) => user_1.UserResolver.getUser(id)));
        manga.data.attributes.author = await user_1.UserResolver.getUser(author.id);
        manga.data.attributes.cover_art = await Promise.all(coverArts.map(({ id }) => cover_art_1.CoverArtResolver.getCoverArt(id)));
        return manga;
    }
    /**
     * Get manga feed with chapters
     * @param mangaId The manga ID
     * @param options Request Options
     */
    async getMangaFeed(mangaId, options = {}) {
        const { data: mangaFeed } = await this.agent.call(`manga/${mangaId}/feed`, {
            params: format_query_params_1.formatQueryParams(options)
        });
        return mangaFeed;
    }
    /**
     * Get manga feed with chapters
     * @param mangaId The manga ID
     * @param options Request Options
     */
    static async getMangaFeed(mangaId, options = {}) {
        const { data: mangaFeed } = await Agent_1.Agent.call(`manga/${mangaId}/feed`, {
            params: format_query_params_1.formatQueryParams(options)
        });
        return mangaFeed;
    }
    async search(options) {
        const { data } = await this.agent.call('manga', {
            params: format_query_params_1.formatQueryParams(options)
        });
        return data;
    }
    static async search(options) {
        const { data } = await Agent_1.Agent.call('manga', {
            params: format_query_params_1.formatQueryParams(options)
        });
        return data;
    }
    /**
     * Get a list of covers belonging to a manga.
     * @param mangaId The manga ID
     */
    async getMangaCovers(mangaId) {
        return cover_art_1.CoverArtResolver.getCoverArts({ manga: [mangaId] });
    }
    /**
     * Get a list of covers belonging to a manga.
     * @param mangaId The manga ID
     */
    static async getMangaCovers(mangaId) {
        return cover_art_1.CoverArtResolver.getCoverArts({ manga: [mangaId] });
    }
    async getTags() {
        const { data: tags } = await this.agent.call('manga/tag');
        return tags;
    }
    static async getTags() {
        const { data: tags } = await Agent_1.Agent.call('manga/tag');
        return tags;
    }
    /**
     * Create Manga
     * @description Create a new Manga
     *
     * **WARNING this API does not have test, cannot guarantee that it's working as expected**
     *
     * If you have permissions and can test it, please report to [github](https://github.com/ejnshtein/mangadex-api)!
     */
    async create(createMangaOptions) {
        const { data } = await this.agent.call('manga', {
            method: 'POST'
        }, createMangaOptions);
        return data;
    }
    /**
     * Get Manga volumes & chapters
     */
    async getMangaVolumesChapters(mangaId, translatedLanguage) {
        const { data } = await this.agent.call(`manga/${mangaId}/aggregate`, {
            params: format_query_params_1.formatQueryParams({
                translatedLanguage: translatedLanguage || []
            })
        });
        return data;
    }
}
exports.MangaResolver = MangaResolver;
