import { ApiBase } from './base';
import { MangaExtendedResponse, MangaFeedResponse, MangaResponse, MangaRatingContent, MangaList, MangaVolumesAndChaptersResponse } from '../../types/data-types/manga';
import { CoverArtsResponse } from '../../types/data-types/cover-art';
import { Language } from '../../types/data-types/language';
import { ApiResponse } from '../../types/response';
import { MangaStatus } from '../../types/data-types/manga-status';
import { MangaPublicationDemographic } from '../../types/data-types/manga-publication-demographic';
import { Tag } from '../../types/data-types/tag';
import { TagsMode } from '../../types/base';
import { Links } from '../../types/data-types/manga-link';
export declare type GetMangaFeedOptions = Partial<{
    limit: number;
    offset: number;
    translatedLanguage: Language[];
    createdAtSince: string;
    updatedAtSince: string;
    publishAtSince: string;
    volume: string;
    chapter: string;
}>;
export declare type SearchMangaOptions = Partial<{
    /**
     * @default 10
     */
    limit: number;
    offset: number;
    title: string;
    authors: string[];
    artists: string[];
    /**
     * Year of release
     */
    year: number;
    includedTags: string[];
    /**
     * @default 'AND'
     */
    includedTagsMode: TagsMode;
    excludedTags: string[];
    /**
     * @default 'OR'
     */
    excludedTagsMode: TagsMode;
    status: MangaStatus;
    originalLanguage: Language[];
    publicationDemographic: MangaPublicationDemographic | 'none';
    /**
     * Manga ids (limited to 100 per request)
     */
    ids: string[];
    contentRating: (MangaRatingContent | 'none')[];
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS
     */
    createdAtSince: string;
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS
     */
    updatedAtSince: string;
    order: {
        createdAt: string;
        updatedAt: string;
    };
}>;
export declare type CreateMangaOptions = {
    title: Record<Language, string>;
    altTitles: Record<Language, string>[];
    description: Record<Language, string>;
    authors: string[];
    artists: string[];
    links: Links;
    originalLanguage: Language;
    lastVolume?: string;
    lastChapter?: string;
    publicationDemographic?: MangaPublicationDemographic;
    status?: MangaStatus;
    year?: number;
    contentRating?: MangaRatingContent;
    modNotes?: string;
    version: number;
};
export declare class MangaResolver extends ApiBase {
    getManga(mangaId: string, options?: {
        /**
         * If true, will additionally fetch data in relationships. (scanlation_group, artist, author)
         */
        withRelationShips?: false;
    }): Promise<MangaResponse>;
    getManga(mangaId: string, options?: {
        /**
         * If true, will additionally fetch data in relationships. (scanlation_group, artist, author)
         */
        withRelationShips?: true;
    }): Promise<MangaExtendedResponse>;
    static getManga(mangaId: string, options?: {
        /**
         * If true, will additionally fetch data in relationships. (scanlation_group, artist, author)
         */
        withRelationShips?: false;
    }): Promise<MangaResponse>;
    static getManga(mangaId: string, options?: {
        /**
         * If true, will additionally fetch data in relationships. (scanlation_group, artist, author)
         */
        withRelationShips?: true;
    }): Promise<MangaExtendedResponse>;
    /**
     * Get manga feed with chapters
     * @param mangaId The manga ID
     * @param options Request Options
     */
    getMangaFeed(mangaId: string, options?: GetMangaFeedOptions): Promise<MangaFeedResponse>;
    /**
     * Get manga feed with chapters
     * @param mangaId The manga ID
     * @param options Request Options
     */
    static getMangaFeed(mangaId: string, options?: GetMangaFeedOptions): Promise<MangaFeedResponse>;
    search(options: SearchMangaOptions): Promise<MangaList>;
    static search(options: SearchMangaOptions): Promise<MangaList>;
    /**
     * Get a list of covers belonging to a manga.
     * @param mangaId The manga ID
     */
    getMangaCovers(mangaId: string): Promise<CoverArtsResponse>;
    /**
     * Get a list of covers belonging to a manga.
     * @param mangaId The manga ID
     */
    static getMangaCovers(mangaId: string): Promise<CoverArtsResponse>;
    getTags(): Promise<ApiResponse<{
        data: Tag;
    }>[]>;
    static getTags(): Promise<ApiResponse<{
        data: Tag;
    }>[]>;
    /**
     * Create Manga
     * @description Create a new Manga
     *
     * **WARNING this API does not have test, cannot guarantee that it's working as expected**
     *
     * If you have permissions and can test it, please report to [github](https://github.com/ejnshtein/mangadex-api)!
     */
    create(createMangaOptions: CreateMangaOptions): Promise<MangaResponse>;
    /**
     * Get Manga volumes & chapters
     */
    getMangaVolumesChapters(mangaId: string, translatedLanguage?: Language[]): Promise<MangaVolumesAndChaptersResponse>;
}
